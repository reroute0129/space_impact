# Отчет по оптимизации курсовой работы
## Space Impact - Performance Optimization Project

---

## 1. Исходная программа

**Проект:** Space Impact - 2D scrolling shooter game
**Язык:** C99
**Библиотеки:** OpenGL, GLEW, GLFW
**Размер кода:** ~930 строк

### Основные компоненты:
- Игровая логика (game.c)
- Рендеринг (renderer.c)
- Управление ресурсами (resources.c)
- Встроенная система бенчмаркинга

---

## 2. Анализ алгоритмической сложности исходной программы

### 2.1 Критический узел: Обнаружение столкновений

Функция `handleCollisions()` (game.c:631-740) является основным узким местом производительности.

**Алгоритмическая сложность:**

```
O(B × E + EB + E + P)
```

Где:
- B = MAX_BULLETS (1000) - пули игрока
- E = MAX_ENEMIES (1000) - враги
- EB = MAX_ENEMY_BULLETS (1000) - вражеские пули
- P = MAX_POWERUPS (1000) - бонусы

**Критический участок** - проверка столкновений пуль с врагами:

```c
for (int i = 0; i < MAX_BULLETS; i++) {           // O(B)
    if (gameState->bullets[i].active) {
        for (int j = 0; j < MAX_ENEMIES; j++) {   // O(E)
            if (gameState->enemies[j].active) {
                // AABB collision check - O(1)
            }
        }
    }
}
```

**Сложность:** O(B × E) = O(1000 × 1000) = **O(1,000,000) операций** на кадр!

### 2.2 Другие компоненты

- `updateGame()`: O(B + E + EB + P + EX) = O(n) - линейная сложность, приемлемо
- `renderGame()`: O(n) - зависит от количества объектов
- Управление ресурсами: O(1) - константная сложность

---

## 3. Профилирование исходной программы

### 3.1 Базовые метрики (Baseline)

Тесты проведены на MacOS (Apple Silicon) с density = процент активных объектов:

| Density | Frames | Avg FPS | 1% Low FPS | Min FPS | Max FPS |
|---------|--------|---------|------------|---------|---------|
| 25%     | 6304   | 630.39  | 216.42     | 73.24   | 924.53  |
| 50%     | 3300   | 329.91  | 143.36     | 133.73  | 396.16  |
| 75%     | 2679   | 267.88  | 162.89     | 142.65  | 336.70  |
| 100%    | 2130   | 213.00  | 110.09     | 103.77  | 246.69  |

**Наблюдения:**
- При увеличении density с 25% до 100% производительность падает в **2.96 раза**
- Подтверждает квадратичную сложность O(n²) обнаружения столкновений
- При 100% density: всего 213 FPS - неприемлемо для игры

---

## 4. Реализованные оптимизации

### 4.1 Машинно-независимая оптимизация #1: Dead Code Elimination & Strength Reduction

**Commit:** 7d69b9d

**Изменения:**
1. **Dead Code Elimination:**
   - Удалена неиспользуемая переменная `enemyCount` (game.c:370)
   - Устранено предупреждение компилятора

2. **Strength Reduction:**
   - Замена дорогих операций деления на умножение:
     ```c
     // До:
     gameState->player.width / 2

     // После:
     const float halfWidth = gameState->player.width * 0.5f;
     ```
   - Улучшена точность константы диагонального движения:
     ```c
     const float diagonalFactor = 0.7071067811865476f;  // sqrt(2)/2
     ```

**Влияние на производительность:** Минимальное (~0.4%), но улучшает качество кода.

---

### 4.2 Машинно-независимая оптимизация #2: Loop Invariant Code Motion

**Commit:** d341c30

**Техника:** Вынос инвариантных вычислений за пределы циклов.

**Изменения:**
```c
void handleCollisions(GameState* gameState) {
    // Кэширование координат игрока (не изменяются в цикле)
    const float playerX = gameState->player.x;
    const float playerY = gameState->player.y;
    const float playerRight = playerX + playerWidth;
    const float playerBottom = playerY + playerHeight;

    for (int i = 0; i < MAX_BULLETS; i++) {
        // Предвычисление границ пули
        const float bulletRight = bulletX + gameState->bullets[i].width;
        const float bulletBottom = bulletY + gameState->bullets[i].height;

        for (int j = 0; j < MAX_ENEMIES; j++) {
            // Использование кэшированных значений
            if (bulletRight < enemyX || bulletX > enemyRight || ...) {
                // ...
            }
        }
    }
}
```

**Результаты:**

| Density | До оптимизации | После | Изменение |
|---------|----------------|-------|-----------|
| 100%    | 213.00 FPS     | 206.83 FPS | -3.0% |

**Анализ:** Небольшая деградация производительности. Современные компиляторы (GCC, Clang) уже выполняют эту оптимизацию автоматически. Дополнительные переменные могут увеличить давление на регистры процессора.

**Образовательная ценность:** Демонстрирует важность профилирования - не все теоретические оптимизации дают практический эффект.

---

### 4.3 Алгоритмическая оптимизация: Active Entity Tracking

**Commit:** 85dbf01

**Стратегия:** Построение списка активных врагов перед проверкой столкновений.

**Принцип:**
```
До:  Проверяем B bullets × E enemies
После: Проверяем B bullets × Ea active_enemies
где Ea << E при низкой плотности
```

**Реализация:**
```c
void handleCollisions(GameState* gameState) {
    // Построение списка активных врагов - O(E)
    static int activeEnemies[MAX_ENEMIES];
    int activeEnemyCount = 0;
    for (int j = 0; j < MAX_ENEMIES; j++) {
        if (gameState->enemies[j].active) {
            activeEnemies[activeEnemyCount++] = j;
        }
    }

    // Проверка только активных врагов - O(B × Ea)
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (!gameState->bullets[i].active) continue;

        for (int idx = 0; idx < activeEnemyCount; idx++) {
            int j = activeEnemies[idx];
            // AABB collision with early rejection
            if (bulletRight < enemyX || bulletX > enemyRight || ...) {
                continue;
            }
            // Collision handling...
        }
    }
}
```

**Алгоритмическая сложность:**

```
До:  O(B × E)
После: O(E + B × Ea) где Ea - количество активных врагов
```

**Теоретический выигрыш:**
При density = 25%: Ea = 0.25E
- Ускорение: 4× (75% меньше проверок)

При density = 100%: Ea = E
- Overhead от построения списка без выигрыша

---

## 5. Результаты после всех оптимизаций

### 5.1 Итоговые метрики

| Density | Baseline | Optimized | Изменение | Speedup |
|---------|----------|-----------|-----------|---------|
| 25%     | 630.39   | 651.16    | +20.77 FPS | **+3.3%** |
| 50%     | 329.91   | 334.51    | +4.60 FPS  | **+1.4%** |
| 75%     | 267.88   | 258.91    | -6.97 FPS  | **-3.3%** |
| 100%    | 213.00   | 209.10    | -3.90 FPS  | **-1.8%** |

### 5.2 Детальный анализ 1% Low FPS

**1% Low FPS** - важная метрика для игр (минимальная частота кадров у 1% худших кадров):

| Density | Baseline 1% Low | Optimized 1% Low | Изменение |
|---------|-----------------|------------------|-----------|
| 25%     | 216.42          | 232.16           | **+7.3%** |
| 50%     | 143.36          | 149.98           | **+4.6%** |
| 75%     | 162.89          | 135.21           | **-17.0%** |
| 100%    | 110.09          | 105.80           | **-3.9%** |

---

## 6. Анализ сложности оптимизированной программы

### 6.1 Теоретическая сложность

**handleCollisions() после оптимизации:**

```
O(E + B × Ea + EB + E + P)
= O(E + B × Ea + EB + P)
```

При низкой активности (Ea << E):
```
O(E + B × Ea) << O(B × E)
```

### 6.2 Практическая эффективность по density

**При 25% density:**
- Ea ≈ 250 (вместо 1000)
- Сокращение проверок: (1000 - 250)/1000 = **75%**
- Реальный прирост: **+3.3%**

**Почему меньше теоретического?**
1. Overhead построения списка: O(E)
2. Дополнительные индирекции через activeEnemies[]
3. Cache misses при непоследовательном доступе

**При 100% density:**
- Ea ≈ 1000 (все враги активны)
- Overhead построения списка без выигрыша
- Регрессия: **-1.8%**

---

## 7. Выводы

### 7.1 Достигнутые результаты

✅ **Реализовано 3 оптимизации:**
1. Dead Code Elimination & Strength Reduction
2. Loop Invariant Code Motion
3. Active Entity Tracking (алгоритмическая)

✅ **Улучшение производительности:**
- При разреженных сценариях (25% density): **+3.3%**
- Улучшение 1% Low FPS на 7.3% при низкой плотности

✅ **Образовательные результаты:**
- Профилирование показало реальные узкие места
- Не все теоретические оптимизации эффективны на практике
- Важность учета реальных сценариев использования

### 7.2 Lessons Learned

1. **Современные компиляторы умны:**
   - Loop invariant code motion часто делается автоматически
   - Strength reduction выполняется на уровне оптимизации -O2/-O3

2. **Алгоритмические оптимизации зависят от данных:**
   - Active entity tracking отлично работает для sparse workloads
   - Добавляет overhead для dense workloads
   - Нужно профилировать типичные сценарии использования

3. **Trade-offs везде:**
   - Кэширование данных ↔ Давление на регистры
   - Предвычисления ↔ Дополнительная память
   - Сложность кода ↔ Производительность

### 7.3 Дальнейшие возможности оптимизации

**Не реализованные, но перспективные:**

1. **Пространственное хеширование (Spatial Grid):**
   - Разделить экран на сетку ячеек
   - Проверять коллизии только в соседних ячейках
   - Потенциал: O(B × E) → O(B + E)

2. **SIMD векторизация:**
   - Использовать SSE/AVX для параллельной обработки AABB
   - Потенциал: 4-8× ускорение на AABB проверках

3. **Structure-of-Arrays (SoA):**
   - Вместо `Enemy[1000]` → `{x[1000], y[1000], ...}`
   - Лучшая векторизация и cache locality

4. **Компиляционные флаги:**
   - `-O3 -march=native -flto`
   - Link-Time Optimization может дать 5-10%

---

## 8. Использованные инструменты

- **Компилятор:** GCC (Apple Clang) с флагами `-O0` для чистого тестирования
- **Профилирование:** Встроенная система бенчмаркинга
- **Система контроля версий:** Git (каждая оптимизация = отдельный коммит)
- **Платформа:** macOS (Apple Silicon M-series)

---

## 9. Приложения

### Структура коммитов Git:

```
2ed6995 - Add baseline benchmarks for optimization analysis
7d69b9d - opt: dead code elimination and strength reduction
d341c30 - opt: loop invariant code motion in collision detection
85dbf01 - opt: algorithmic optimization with active entity tracking
```

### Файлы с результатами:

- `benchmarks/baseline.txt` - Полные результаты всех тестов
- `OPTIMIZATION_REPORT.md` - Данный отчет

---

**Автор:** [Ваше имя]
**Дата:** November 2025
**Курс:** Архитектура компьютера / Оптимизация программ
